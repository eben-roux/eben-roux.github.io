---
layout: post
title: "Order.Total(), CQS [Meyer], and object semantics"
date: 2009-10-16 13:24:00
comments: true
categories: 
---

<p>Right, so I have seen some examples of determining an order total by adding the totals for the order lines, and then applying tax, etc.&nbsp; Firstly, however, we need to determine whether an order would actually ever do this.&nbsp; Why?&nbsp; Because an order represents an agreement of sorts and is a near-immutable object.&nbsp; One typically starts out with a quote (or shopping cart).&nbsp; This quote may have items that are on special.&nbsp; We may even apply a certain discount (based on our client segmentation or a discretionary discount) to the quote.&nbsp; There will probably never really be any rules around how many quotes a client may have or maximum amounts or the like.</p>
<p>Now once a client accepts a quote it becomes an order.&nbsp; The quote can, for all intents and purposes, disappear from the transaction store since it is now history.&nbsp; The order, on the other hand, is now an agreement that needs to be fulfilled.&nbsp; Some items may be placed on back-order or be removed totally if stock is no longer available.&nbsp; But the point is that the order now has it's own life cycle.&nbsp; It may even be cancelled in it's entirety.&nbsp; So why can we not 'edit' an order?&nbsp; The problem lies in determining the validity.&nbsp; Let's say that yesterday there was a special on lollipops and the client ended up ordering 100.&nbsp; Today he phones and says that he would rather like to order 200.&nbsp; What pricing would one use?&nbsp; The simplest would be to give the client a new quote and create a new order for the next 100 lollipos.&nbsp; The complete data used to quote the client is now available for this new order.</p>
<p>Now let's get to the<span style="font-family: courier new,courier;"> <strong>Order.Total()</strong></span>.&nbsp; Now our order may still need to do this since we may place certain of the items on a <span style="font-family: courier new,courier;">BackOrder </span>and need to recalculate the total based on the values stored in the remaining items.&nbsp; A typical scenario is to run through the order items and add up the totals.&nbsp; Now this, to me, seems to go against CQS [Meyer] since our query is changing the object state by changing the total.&nbsp; "But wait!", I hear you say, "The total is a calculated value so it is not state."&nbsp; This may be true when the order is the Aggregate Root for the use case, but what happens when we have a rule such as "A client may not have active orders totalling more than $5,000"?&nbsp; Now I know with an ORM the order items may be lazy-loaded.&nbsp; I do not use an ORM and lazy-loading borders on evil (IMO).&nbsp; So in the Customer class may have an <span style="font-family: courier new,courier;">AddOrder </span>method for this use-case.&nbsp; But how does it get the total.&nbsp; Well, the total has to be stored as state.</p>
<h3>Changing the order total</h3>
<p>OK, so we could have a method such as CalculateTotal() on the order.&nbsp; But <em>that</em> would result in the order not being valid at all times since I could add an order line and call Total() before calling CalculateTotal().&nbsp; So the answer is to perhaps call CalculateTotal() internally each time it needs to be called and to then keep the method private.</p>