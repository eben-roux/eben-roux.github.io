---
layout: post
title: "The 'future' of programming"
date: 2016-12-19 12:00:00
comments: false
categories:
- general
tags:
- unclebob
---

After watching ["Uncle" Bob Martin - "The Future of Programming"](https://www.youtube.com/watch?v=ecIWPzGEbFc) I got to thinking about the software industry again.  I got to this video via [AGILE HAS FAILED. A PEEK AT THE FUTURE OF PROGRAMMING](https://www.codingame.com/blog/agile-failed-peek-future-programming/) and I'm pretty sure that was again via my daily [CodeProject Newsletter](https://www.codeproject.com/Feature/Insider/).

Uncle Bob has been around for a while  and has a fair bit of insight into the software world.  There are a couple of things in his presentation that caught my attention.  The reference to the following statement by Alan Turing was particularly interesting:

> "In order to supply the machine with these problems we shall need a great number of mathematicians of ability." - Alan Turing

Throughout Uncle Bob's talk I was thinking about how much computing has actually changed.  He mentioned how, in the early days, the "programmers" were actually engineers, mathematicians, or scientists.  These folks were usually a bit older and didn't need any management.  They knew what they needed to do and got the job done.  That may very well be true but there is also the size factor.  Computers really could not do much.  Programs were *much* smaller and the architecture of the system was constrained to such a degree that there probably would not necessarily be a team of tens or hundreds of folks.  Working on a problem in isolation probably wasn't uncommon.

My first computer was a [Commodore VIC-20](https://en.wikipedia.org/wiki/Commodore_VIC-20).  Once you switched it on you roughly 3.5KB of RAM to write your BASIC program.  Now if you go ahead and open Microsoft Word and save a blank document you'll find that the size of the empty document is probably more than that.  On my machine the size on the disk is 12KB.  Things have changed.

Nowadays we have rather large software projects.  So-mcuh-so that one probably would not come across many software projects that require only a single programmer.  My very first professional programming job in 1995 was a contract to develop a **Soil Conservation System** at the **Glen Agricultural Development Institute**.  I was the sole programmer using Visual Basic 3.0 and Microsoft Access 1.0.  There may have been some Crystal Reports in there too.  The point is that I had very little guidance and completed the project alone.  Back to today and any significant software project is going to require multiple disciplines.  This means that there is going to be more communication between people.  We need to have various bits interact with each other.  This has led to some monstrous siloed implementations over the years where we have a high degree of coupling and we could end up [grinding to a halt](http://www.artima.com/weblogs/viewpost.jsp?thread=51769).  Identifying the interactions and defining the overall architecture is something that, if we get it wrong, can have dire consequences for our product.

## On mathematicians and ability

Do we really need mathematicians?  I don't think so.  There are many aspects to software development that are not necessarily mathematical in nature.  Being a mathematical genius probably isn't going to hurt.  I think the more important bit about Turing's statement is the *ability* factor.

How do we measure ability?  Will university degrees tell us much?  How about all the certifications that are available?  None of these are any true indication of ability.  The *noun* **Ability** is defined as:

* possession of the means or skill to do something.
* talent, skill, or proficiency in a particular area.

Uncle Bob ends his talk by saying that if we, as programmers, do not regulate ourselves then governments will eventually do so.  

Perhaps.

Unfortunately it is not possible to regulate, or manage, ability into programmers.  You either have it or you don't.  Some programmers strive to improve themselves whilst others are happy to just take home a salary.  Some programmers are fine with taking the responsibility for their decisions and actions while others stand back and are content following set tasks without any decision-making involved.

However, there are various skills, and levels of skill, required when developing software.  Who gets to decide what the regulations will look like?  It is true that business folks do not understand technology to the degree that they can measure outcomes or even compare programmers to each other.  This is a problem.

I have come to the conclusion that much of what we do as programmers falls in the realm of [tacit knowledgte](https://en.wikipedia.org/wiki/Tacit_knowledge).  It is almost impossible to convince another programmer, of any level of ability, that one design or approach may be superior to another.  If tacit knowledge is difficult to transfer then measuring it will be equally difficult.

## Is agile dead?

Also interesting is that Uncle Bobs has conceeded that the agile movement is, for the most part, dead.

Something that was created by a group of technical gurus has been annexed by business.  When *scrum* came to the fore it immediately seemed as though it was trying to introduce some structure to agile.  I guess that was the beginning of the end.

## Regulation

I highly doubt whether regulation will ever be an option.  I have seen governance in companies that is a total farce.  Any regulation will result in increased costs and a whole new business built around the regulators and assessors and people of that ilk.

This will not improve the quality of software.

We need more people of ability.  That is one thing we cannot escape.

