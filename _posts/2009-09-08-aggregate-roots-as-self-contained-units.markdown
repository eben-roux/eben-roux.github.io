---
layout: post
title: "Aggregate Roots as self-contained units"
date: 2009-09-08 07:23:00
comments: true
categories: 
---

<p>OK, I know Aggregate Roots (AR) are a consistency boundary but I believe that they need to do even more.&nbsp; As Eric Evans mentions in [DDD] relationships need to be scaled down to simple forms or even eliminated since it leads to simpler software.&nbsp; I agree.</p>
<p>I think we, as developers, have managed to paint ourselves into a corner over the years and since some of our techniques have been developed over a long period we just don't see it.&nbsp; It's like the guy sitting on his porch with his dog lying next to him.&nbsp; The dog is moaning and groaning.&nbsp; A neighbour walks by and enquires about the dog.&nbsp; So the chap answers:&nbsp; "Ther is a nail poking through the floorboard and the dog is lying on top of it.".&nbsp; So the neighbour asks: "Why doesn't the dog just move.".&nbsp; And the answer: "It doesn't hurt enough."</p>
<p>When philosophizing about some of the software issues that bug me I like to think about a time when there were no computers.&nbsp; How were these situations handled using manual systems?&nbsp; Let's take an Order (again).&nbsp; That piece of paper would contain absolutely all the information required about the order.&nbsp; There would be no customer defined but maybe a customer number.&nbsp; We used to have those 'traditional' primary and foreign keys in our databases.&nbsp; Problem was, whenever we <strong><em>changed</em></strong> the key (for whatever reason) we needed to update the foreign keys, etc.&nbsp; So how would this work in a manual system?&nbsp; Probably a little note next to the number saying something like "new number C01-2009".&nbsp; So no data was actually <em>changed</em>.</p>
<p>There proponents of CR as opposed to CRUD.&nbsp; So data is only ever added and read.&nbsp; However, the same idea can be achieved using CQS [Architecture].&nbsp; Although there will be updates the entire history will remain so it is essentially CR with a latest snapshot.</p>
<p>Over time, then, we got around to the idea of <em>surrogate keys</em>.&nbsp; But I think that this has lead to the higher coupling I mentioned in a <a href="http://www.ebenroux.co.za/post.aspx?id=195cc850-f763-4674-8fda-c3975a47abfc">previous post</a>.&nbsp; One will also often hear arguments along the line of requiring the customer object for discount information, etc. (Gold, Silver, Bronze clients).&nbsp; But I reckon that *that* information simply serves as defaults.&nbsp; Once the customer places an order and the customer is a gold customer at that point in time then the discount is assigned to the order and that's that.&nbsp; Shoud the customer be downgraded the next day the original data remains in tact.</p>
<p>The same can be said of the items being ordered.&nbsp; The actual products aren't *really* required in the object structure.&nbsp; The items can be loaded with the relevant description and bar codes and SKU codes and the like and if ever a lookup is required there should be more than enough information to retrieve whatever is required.&nbsp; Even database joins are possible.</p>